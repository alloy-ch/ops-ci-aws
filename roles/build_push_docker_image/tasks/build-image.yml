---

- name: '[{{ ecr_repository_name }}] set image name and tag for the image to be built'
  set_fact:
    comp_image: '{{ ecr_repository_name }}'
    comp_tag: '{{ project_version }}'

- name: "[{{ ecr_repository_name }}] assemble the image's names"
  set_fact:
    docker_image_with_tag: '{{ comp_image }}:{{ comp_tag }}'
    docker_image_full_name_and_tag: '{{ ecr_registry_uri }}:{{ comp_tag }}'
    docker_image_full_name_with_latest_tag: '{{ ecr_registry_uri }}:latest'

- name: '[{{ ecr_repository_name }}] clear existing docker_build_args_str'
  set_fact:
    docker_build_args_str: ''

- name: '[{{ ecr_repository_name }}] build docker_build_args_str'
  set_fact:
    docker_build_args_str: '{{ docker_build_args_str }} --build-arg {{ item.key }}="{{ item.value }}"'
  with_items: '{{ docker_build_args | default({}) | dict2items }}'
  when: docker_build_args is defined and docker_build_args.keys()|length > 0
  no_log: '{{ ansible_verbosity < 3 }}'

- name: '[{{ ecr_repository_name }}] get NPMRC_ENCODED from the environment variable'
  set_fact:
    npmrc_encoded: "{{ lookup('env', 'NPMRC_ENCODED') }}"
  no_log: '{{ ansible_verbosity < 3 }}'

- name: '[{{ ecr_repository_name }}] safeguard'
  fail: msg="missing environment variable 'NPMRC_ENCODED'"
  when: npmrc_encoded == ''

- include_tasks: 'platform-determination.yml'

- debug:
    msg: 'The Docker image is to be built for platform(s) "{{ buildx_platform_param }}" at platform "{{ local_platform }}"'

- name: '[{{ ecr_repository_name }}] check Docker environment'
  command: docker version

- name: 'do not use BuildKit if possible'
  when: buildx_platform_param == local_platform
  block:
    - name: '[{{ ecr_repository_name }}] build the image'
      command: |
        docker build --platform {{ local_platform }} --rm --tag {{ docker_image_full_name_and_tag }} {{ code_path }} --build-arg NPMRC_ENCODED="$NPMRC_ENCODED" {{ docker_build_args_str }}
      no_log: '{{ ansible_verbosity < 3 }}'
    - name: '[{{ ecr_repository_name }}] push the image to ECR'
      shell: 'docker push {{ docker_image_full_name_and_tag }} > /dev/null'
    - name: '[{{ ecr_repository_name }}] tag the local image without scope'
      command: 'docker tag {{ docker_image_full_name_and_tag}} {{ docker_image_with_tag }}'
      no_log: '{{ ansible_verbosity < 3 }}'
    - name: '[{{ ecr_repository_name }}] ad-hoc deployment: get the image repo digest'
      when: adhoc_deploy
      shell: docker inspect {{ docker_image_full_name_and_tag }} | jq -crM '.[0].RepoDigests[] | select(startswith("{{ ecr_registry_uri }}"))'
      register: docker_inspect
    - name: '[{{ ecr_repository_name }}] ad-hoc deployment: use the image repo digest as the docker image'
      when: adhoc_deploy
      set_fact:
        docker_image_full_name_and_tag: '{{ docker_inspect.stdout }}'

- name: 'use BuildKit if needed'
  when: buildx_platform_param != local_platform
  block:
    - name: '[{{ ecr_repository_name }}] check Docker BuildKit'
      command: docker buildx version
    - name: '[{{ ecr_repository_name }}] inspect our image builder'
      command: docker buildx inspect rcplus
      no_log: true
      ignore_errors: true
      register: r_buildx_rcplus
    - name: '[{{ ecr_repository_name }}] use the builder if available'
      when: r_buildx_rcplus.rc == 0
      command: docker buildx use rcplus
    - name: '[{{ ecr_repository_name }}] initialize the builder if needed'
      when: r_buildx_rcplus.rc != 0
      shell: |
        docker buildx create --bootstrap --name rcplus --driver docker-container --platform linux/amd64,linux/arm64 --use --buildkitd-flags '--allow-insecure-entitlement security.insecure'
    - name: '[{{ ecr_repository_name }}] install emulators'
      when: r_buildx_rcplus.rc != 0
      shell: |
        docker run --privileged --rm public.ecr.aws/eks-distro-build-tooling/binfmt-misc:qemu-v7.0.0 --install arm64,amd64
    - name: '[{{ ecr_repository_name }}] build the image'
      shell: |
        docker buildx build --allow security.insecure --push --platform {{ buildx_platform_param }} --builder rcplus {{ extra_buildx_build_args }} --tag {{ docker_image_full_name_and_tag }} --tag {{ docker_image_full_name_with_latest_tag }} {{ code_path }} --build-arg NPMRC_ENCODED="$NPMRC_ENCODED" {{ docker_build_args_str }}
      register: r_buildx_build
      no_log: '{{ ansible_verbosity < 3 }}'
    - name: '[{{ ecr_repository_name }}] ad-hoc deployment: use the image repo digest as the docker image'
      # NOTE-zw: hacky workaround here. Because docker-buildx does not leave a local footprint, and we cannot inspect
      # a remote image without pulling it back. Here we take the quiet stdout output of buildx, which is sha256:xxx...xxx
      when: adhoc_deploy
      set_fact:
        docker_image_full_name_and_tag: '{{ ecr_registry_uri }}@{{ r_buildx_build.stdout }}'
